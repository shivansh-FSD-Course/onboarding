<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAISA Onboarding Assistant</title>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Mammoth.js for DOCX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <!-- React -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,400;0,8..60,500;0,8..60,600;1,8..60,400&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #faf6f1;
            --bg-secondary: #f5ede4;
            --bg-tertiary: #efe5d8;
            --bg-hover: #e8dccb;
            --border: #d9c9b5;
            --border-light: #c4b29a;
            --text-primary: #2c2416;
            --text-secondary: #5c4d3a;
            --text-muted: #8c7a62;
            --accent: #b85c38;
            --accent-hover: #a04e2e;
            --accent-light: rgba(184, 92, 56, 0.1);
            --success: #5a8a5c;
            --success-bg: rgba(90, 138, 92, 0.15);
            --warning: #c4883a;
            --warning-bg: rgba(196, 136, 58, 0.15);
            --error: #c25454;
            --error-bg: rgba(194, 84, 84, 0.15);
            --info: #5a7a9a;
            --info-bg: rgba(90, 122, 154, 0.15);
            --abstain: #8a6aaa;
            --abstain-bg: rgba(138, 106, 170, 0.15);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Source Serif 4', Georgia, serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.7;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 340px 1fr;
            min-height: 100vh;
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 28px;
            overflow-y: auto;
            max-height: 100vh;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 14px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border);
        }
        
        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent), #d4886a);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 20px;
            color: white;
            box-shadow: 0 4px 12px rgba(184, 92, 56, 0.25);
        }
        
        .logo-text h1 {
            font-size: 22px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        
        .logo-text span {
            font-size: 13px;
            color: var(--text-muted);
        }
        
        .section {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .input-group label {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        input[type="password"],
        input[type="text"] {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 14px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-light);
        }
        
        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 18px;
            color: var(--text-primary);
            font-family: 'Source Serif 4', serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: var(--bg-hover);
        }
        
        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--accent-hover);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Status box */
        .status-box {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
        }
        
        .status-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .status-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .status-icon.loading {
            background: var(--info-bg);
            color: var(--info);
            animation: pulse 2s infinite;
        }
        
        .status-icon.success {
            background: var(--success-bg);
            color: var(--success);
        }
        
        .status-icon.error {
            background: var(--error-bg);
            color: var(--error);
        }
        
        .status-icon.waiting {
            background: var(--warning-bg);
            color: var(--warning);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        
        .status-title {
            font-size: 15px;
            font-weight: 500;
        }
        
        .status-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-left: 48px;
        }
        
        .status-progress {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 12px;
            margin-left: 48px;
        }
        
        .status-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #d4886a);
            border-radius: 3px;
            width: 30%;
            animation: progressMove 1.5s ease-in-out infinite;
        }
        
        @keyframes progressMove {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }
        
        .help-text {
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.5;
        }
        
        .help-text a {
            color: var(--accent);
            text-decoration: none;
        }
        
        .help-text a:hover {
            text-decoration: underline;
        }
        
        /* Upload zone */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 14px;
            padding: 28px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-primary);
        }
        
        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-light);
        }
        
        .upload-zone.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upload-zone p {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .upload-zone .formats {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 8px;
        }
        
        /* Document list */
        .doc-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .doc-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
        }
        
        .doc-item .name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
            font-weight: 500;
        }
        
        .doc-item .chunks {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .doc-item .remove {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .doc-item .remove:hover {
            color: var(--error);
            background: var(--error-bg);
        }
        
        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
            border: 1px solid var(--border);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--accent);
        }
        
        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Main content */
        .main-content {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .chat-header {
            padding: 24px 36px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }
        
        .chat-header h2 {
            font-size: 20px;
            font-weight: 500;
        }
        
        .chat-header p {
            font-size: 14px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 36px;
            display: flex;
            flex-direction: column;
            gap: 28px;
        }
        
        .message {
            max-width: 800px;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message-user {
            align-self: flex-end;
        }
        
        .message-user .message-content {
            background: var(--accent);
            color: white;
            border-radius: 18px 18px 4px 18px;
            padding: 14px 18px;
        }
        
        .message-assistant .message-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 18px 18px 18px 4px;
            padding: 18px 22px;
        }
        
        .message-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Trust indicator */
        .trust-indicator {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid var(--border);
        }
        
        .trust-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 500;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
        }
        
        .trust-high { background: var(--success-bg); color: var(--success); }
        .trust-medium { background: var(--warning-bg); color: var(--warning); }
        .trust-low { background: var(--error-bg); color: var(--error); }
        .trust-abstain { background: var(--abstain-bg); color: var(--abstain); }
        
        .trust-details {
            color: var(--text-muted);
            font-size: 11px;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        /* Sources */
        .sources {
            margin-top: 14px;
        }
        
        .sources-title {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .source-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .source-item .source-doc {
            color: var(--accent);
            font-weight: 500;
        }
        
        .source-item .source-text {
            color: var(--text-secondary);
            margin-top: 6px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        /* Chat input */
        .chat-input-container {
            padding: 28px 36px;
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
        }
        
        .chat-input-wrapper {
            display: flex;
            gap: 14px;
            max-width: 800px;
        }
        
        .chat-input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px 20px;
            color: var(--text-primary);
            font-family: 'Source Serif 4', serif;
            font-size: 15px;
            resize: none;
            min-height: 56px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-light);
        }
        
        .chat-input::placeholder {
            color: var(--text-muted);
        }
        
        .send-btn {
            width: 56px;
            height: 56px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-muted);
        }
        
        .loading-dots {
            display: flex;
            gap: 5px;
        }
        
        .loading-dots span {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        
        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .empty-state h3 {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .empty-state p {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        /* Settings */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
        }
        
        .slider-header label {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .slider-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            color: var(--accent);
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

        /* Processing overlay */
        .processing-overlay {
            position: fixed;
            inset: 0;
            background: rgba(250, 246, 241, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .processing-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 420px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        .processing-modal h3 {
            margin-bottom: 12px;
        }

        .processing-modal p {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #d4886a);
            border-radius: 4px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // BM25 Implementation
        class BM25 {
            constructor(documents, k1 = 1.5, b = 0.75) {
                this.k1 = k1;
                this.b = b;
                this.documents = documents;
                this.avgDocLength = 0;
                this.docLengths = [];
                this.termFreqs = [];
                this.docFreqs = {};
                this.idf = {};
                this.N = documents.length;
                this._buildIndex();
            }
            
            _tokenize(text) {
                return text.toLowerCase().replace(/[^\w\s]/g, ' ').split(/\s+/).filter(t => t.length > 1);
            }
            
            _buildIndex() {
                let totalLength = 0;
                for (const doc of this.documents) {
                    const tokens = this._tokenize(doc);
                    this.docLengths.push(tokens.length);
                    totalLength += tokens.length;
                    const tf = {};
                    const seen = new Set();
                    for (const token of tokens) {
                        tf[token] = (tf[token] || 0) + 1;
                        if (!seen.has(token)) {
                            this.docFreqs[token] = (this.docFreqs[token] || 0) + 1;
                            seen.add(token);
                        }
                    }
                    this.termFreqs.push(tf);
                }
                this.avgDocLength = totalLength / this.N;
                for (const term in this.docFreqs) {
                    this.idf[term] = Math.log(1 + (this.N - this.docFreqs[term] + 0.5) / (this.docFreqs[term] + 0.5));
                }
            }
            
            search(query, topK = 10) {
                const queryTokens = this._tokenize(query);
                const scores = [];
                for (let i = 0; i < this.N; i++) {
                    let score = 0;
                    const docLength = this.docLengths[i];
                    const tf = this.termFreqs[i];
                    for (const term of queryTokens) {
                        if (tf[term]) {
                            const termFreq = tf[term];
                            const idf = this.idf[term] || 0;
                            score += idf * ((termFreq * (this.k1 + 1)) / (termFreq + this.k1 * (1 - this.b + this.b * (docLength / this.avgDocLength))));
                        }
                    }
                    scores.push({ index: i, score });
                }
                return scores.sort((a, b) => b.score - a.score).slice(0, topK);
            }
        }

        function cosineSimilarity(a, b) {
            let dot = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dot += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            return dot / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        function chunkText(text, size = 250, overlap = 50) {
            const words = text.split(/\s+/);
            const chunks = [];
            for (let i = 0; i < words.length; i += size - overlap) {
                const chunk = words.slice(i, i + size).join(' ');
                if (chunk.trim().length > 50) chunks.push(chunk);
            }
            return chunks;
        }

        // HuggingFace API
        class HuggingFaceAPI {
            constructor(apiKey) {
                this.apiKey = apiKey;
                this.baseUrl = 'https://api-inference.huggingface.co/models';
                this.embeddingModel = 'BAAI/bge-large-en-v1.5';
                
                // Option A (recommended): Llama 3 Instruct
                this.llmModel = 'meta-llama/Meta-Llama-3-8B-Instruct';
                
                // Option B (bigger): 
                // this.llmModel = 'meta-llama/Meta-Llama-3-70B-Instruct';
                
                // Option C (older Llama 2):
                // this.llmModel = 'meta-llama/Llama-2-13b-chat-hf';
                
                this.nliModel = 'microsoft/deberta-v3-large-mnli';

            }

            async _fetch(model, payload, onStatus) {
                for (let i = 0; i < 15; i++) {
                    try {
                        const response = await fetch(`${this.baseUrl}/${model}`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.apiKey}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(payload),
                        });

                        if (response.status === 503) {
                            const data = await response.json();
                            const wait = data.estimated_time || 20;
                            if (onStatus) onStatus(`Model is waking up (~${Math.ceil(wait)}s)...`);
                            await new Promise(r => setTimeout(r, Math.min(wait * 1000, 30000)));
                            continue;
                        }
                        
                        if (response.status === 401 || response.status === 403) {
                            throw new Error('INVALID_KEY');
                        }

                        if (!response.ok) throw new Error(`API error: ${response.status}`);
                        return await response.json();
                    } catch (error) {
                        if (error.message === 'INVALID_KEY') throw error;
                        if (i === 14) throw error;
                        if (onStatus) onStatus(`Retrying connection (${i + 2}/15)...`);
                        await new Promise(r => setTimeout(r, 3000));
                    }
                }
            }

            async getEmbedding(text, onStatus) {
                return this._fetch(this.embeddingModel, { inputs: text, options: { wait_for_model: true } }, onStatus);
            }

            async getEmbeddings(texts, onStatus) {
                return this._fetch(this.embeddingModel, { inputs: texts, options: { wait_for_model: true } }, onStatus);
            }

            async generateAnswer(context, question, onStatus) {
                const prompt = `<s>[INST] You are a helpful onboarding assistant. Answer questions ONLY based on the provided context. If the answer is not in the context, say "I don't have enough information to answer this."

Context:
${context}

Question: ${question} [/INST]`;

                const result = await this._fetch(this.llmModel, {
                    inputs: prompt,
                    parameters: { max_new_tokens: 500, temperature: 0.1, return_full_text: false, do_sample: false },
                    options: { wait_for_model: true }
                }, onStatus);

                return result[0]?.generated_text || "Failed to generate response.";
            }

            async checkEntailment(premise, hypothesis) {
                const result = await this._fetch(this.nliModel, {
                    inputs: `${premise} [SEP] ${hypothesis}`,
                    options: { wait_for_model: true }
                });
                const ent = result.find(r => r.label === 'ENTAILMENT');
                const con = result.find(r => r.label === 'CONTRADICTION');
                return { entailment: ent?.score || 0, contradiction: con?.score || 0 };
            }
        }

        // Main App
        function App() {
            const [apiKey, setApiKey] = useState(localStorage.getItem('hf_api_key') || '');
            const [status, setStatus] = useState('idle');
            const [statusMsg, setStatusMsg] = useState('');
            const [documents, setDocuments] = useState([]);
            const [chunks, setChunks] = useState([]);
            const [embeddings, setEmbeddings] = useState([]);
            const [bm25Index, setBm25Index] = useState(null);
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [processing, setProcessing] = useState(false);
            const [procStatus, setProcStatus] = useState('');
            const [procProgress, setProcProgress] = useState(0);
            const [loading, setLoading] = useState(false);
            const [trustThreshold, setTrustThreshold] = useState(0.5);
            const [hybridLambda, setHybridLambda] = useState(0.5);
            const [topK, setTopK] = useState(5);
            
            const chatEnd = useRef(null);
            const fileInput = useRef(null);
            const api = useRef(null);
            const timeout = useRef(null);

            useEffect(() => {
                if (apiKey) {
                    localStorage.setItem('hf_api_key', apiKey);
                    api.current = new HuggingFaceAPI(apiKey);
                    if (timeout.current) clearTimeout(timeout.current);
                    timeout.current = setTimeout(validateKey, 500);
                } else {
                    setStatus('idle');
                    setStatusMsg('');
                }
                return () => { if (timeout.current) clearTimeout(timeout.current); };
            }, [apiKey]);

            useEffect(() => {
                chatEnd.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            async function validateKey() {
                if (!apiKey) return;
                if (!apiKey.startsWith('hf_')) {
                    setStatus('error');
                    setStatusMsg('API key should start with "hf_"');
                    return;
                }
                
                setStatus('loading');
                setStatusMsg('Connecting to HuggingFace...');
                
                try {
                    await api.current.getEmbedding('test', (msg) => setStatusMsg(msg));
                    setStatus('connected');
                    setStatusMsg('Ready to use!');
                } catch (e) {
                    setStatus('error');
                    setStatusMsg(e.message === 'INVALID_KEY' ? 'Invalid API key' : `Error: ${e.message}`);
                }
            }

            async function processFile(file) {
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'pdf') {
                    const ab = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
                    const pages = [];
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const content = await page.getTextContent();
                        pages.push(content.items.map(item => item.str).join(' '));
                    }
                    return pages.join('\n\n');
                } else if (ext === 'docx') {
                    const ab = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer: ab });
                    return result.value;
                } else if (ext === 'json') {
                    return JSON.stringify(JSON.parse(await file.text()), null, 2);
                }
                return await file.text();
            }

            async function handleUpload(files) {
                if (status !== 'connected') return;
                setProcessing(true);
                setProcProgress(0);
                
                const newDocs = [];
                const newChunks = [];

                for (let i = 0; i < files.length; i++) {
                    setProcStatus(`Reading ${files[i].name}...`);
                    try {
                        const text = await processFile(files[i]);
                        const fileChunks = chunkText(text).map((chunk, idx) => ({
                            text: chunk,
                            docName: files[i].name,
                            chunkIndex: idx,
                        }));
                        newDocs.push({ name: files[i].name, chunkCount: fileChunks.length });
                        newChunks.push(...fileChunks);
                        setProcProgress((i + 1) / files.length * 50);
                    } catch (e) {
                        console.error(e);
                    }
                }

                setDocuments(prev => [...prev, ...newDocs]);
                const allChunks = [...chunks, ...newChunks];
                setChunks(allChunks);
                setBm25Index(new BM25(allChunks.map(c => c.text)));
                setProcProgress(60);

                const batchSize = 10;
                const newEmb = [...embeddings];
                
                for (let i = embeddings.length; i < allChunks.length; i += batchSize) {
                    const batch = allChunks.slice(i, Math.min(i + batchSize, allChunks.length));
                    setProcStatus(`Embedding ${Math.min(i + batchSize, allChunks.length)}/${allChunks.length}...`);
                    try {
                        const batchEmb = await api.current.getEmbeddings(batch.map(c => c.text));
                        newEmb.push(...batchEmb);
                    } catch (e) {
                        newEmb.push(...batch.map(() => new Array(1024).fill(0)));
                    }
                    setProcProgress(60 + ((i - embeddings.length + batch.length) / (allChunks.length - embeddings.length)) * 40);
                }
                
                setEmbeddings(newEmb);
                setProcessing(false);
            }

            async function hybridSearch(query) {
                if (chunks.length === 0) return [];
                const bm25Results = bm25Index.search(query, topK * 2);
                const bm25Scores = new Array(chunks.length).fill(0);
                const maxBm25 = Math.max(...bm25Results.map(r => r.score), 1);
                bm25Results.forEach(r => { bm25Scores[r.index] = r.score / maxBm25; });

                const qEmb = await api.current.getEmbedding(query);
                const vecScores = embeddings.map(emb => cosineSimilarity(qEmb, emb));
                const maxVec = Math.max(...vecScores, 0.001);

                return chunks.map((chunk, i) => ({
                    chunk, index: i,
                    hybridScore: hybridLambda * bm25Scores[i] + (1 - hybridLambda) * (vecScores[i] / maxVec),
                })).sort((a, b) => b.hybridScore - a.hybridScore).slice(0, topK);
            }

            async function calcTrust(answer, sources) {
                const retrieval = sources.reduce((a, s) => a + s.hybridScore, 0) / sources.length;
                let entailment = 0;
                for (const src of sources.slice(0, 2)) {
                    try {
                        const r = await api.current.checkEntailment(src.chunk.text, answer.slice(0, 500));
                        entailment += Math.max(0, r.entailment - r.contradiction * 0.5);
                    } catch (e) {}
                }
                entailment /= Math.min(sources.length, 2);
                const ansWords = new Set(answer.toLowerCase().split(/\s+/));
                const srcWords = new Set(sources.flatMap(s => s.chunk.text.toLowerCase().split(/\s+/)));
                const attribution = [...ansWords].filter(w => srcWords.has(w)).length / ansWords.size;
                return { overall: 0.3 * retrieval + 0.4 * entailment + 0.3 * attribution, retrieval, entailment, attribution };
            }

            async function handleSubmit() {
                if (!input.trim() || loading || chunks.length === 0) return;
                const query = input.trim();
                setInput('');
                setMessages(prev => [...prev, { type: 'user', content: query }]);
                setLoading(true);

                try {
                    const results = await hybridSearch(query);
                    if (results.length === 0) {
                        setMessages(prev => [...prev, { type: 'assistant', content: "No relevant information found.", trustScore: { overall: 0 }, sources: [], abstained: true }]);
                    } else {
                        const context = results.map((r, i) => `[Source ${i + 1}]:\n${r.chunk.text}`).join('\n\n');
                        const answer = await api.current.generateAnswer(context, query);
                        const trust = await calcTrust(answer, results);
                        const abstain = trust.overall < trustThreshold;
                        setMessages(prev => [...prev, {
                            type: 'assistant',
                            content: abstain ? "I'm not confident enough to answer this based on the documents." : answer,
                            trustScore: trust, sources: results, abstained: abstain
                        }]);
                    }
                } catch (e) {
                    setMessages(prev => [...prev, { type: 'assistant', content: `Error: ${e.message}`, trustScore: { overall: 0 }, sources: [], abstained: true }]);
                }
                setLoading(false);
            }

            function removeDoc(name) {
                setDocuments(prev => prev.filter(d => d.name !== name));
                const remaining = chunks.filter(c => c.docName !== name);
                setChunks(remaining);
                if (remaining.length > 0) {
                    setBm25Index(new BM25(remaining.map(c => c.text)));
                    setEmbeddings(prev => chunks.map((c, i) => c.docName !== name ? i : -1).filter(i => i !== -1).map(i => prev[i]));
                } else {
                    setBm25Index(null);
                    setEmbeddings([]);
                }
            }

            function getTrust(score) {
                if (score >= 0.7) return { label: 'High Confidence', class: 'trust-high' };
                if (score >= 0.5) return { label: 'Medium Confidence', class: 'trust-medium' };
                if (score >= 0.3) return { label: 'Low Confidence', class: 'trust-low' };
                return { label: 'Abstained', class: 'trust-abstain' };
            }

            return (
                <div className="app-container">
                    {processing && (
                        <div className="processing-overlay">
                            <div className="processing-modal">
                                <h3>Processing Documents</h3>
                                <p>{procStatus}</p>
                                <div className="progress-bar">
                                    <div className="progress-fill" style={{ width: `${procProgress}%` }} />
                                </div>
                            </div>
                        </div>
                    )}

                    <aside className="sidebar">
                        <div className="logo">
                            <div className="logo-icon">M</div>
                            <div className="logo-text">
                                <h1>MAISA</h1>
                                <span>Onboarding Assistant</span>
                            </div>
                        </div>

                        <div className="section">
                            <div className="section-title">API Configuration</div>
                            <div className="input-group">
                                <label>HuggingFace API Key</label>
                                <input
                                    type="password"
                                    value={apiKey}
                                    onChange={(e) => setApiKey(e.target.value)}
                                    placeholder="hf_xxxxxxxxxxxx"
                                />
                                <p className="help-text">
                                    Get your free key at <a href="https://huggingface.co/settings/tokens" target="_blank">huggingface.co</a>
                                </p>
                            </div>
                            
                            {apiKey && (
                                <div className="status-box">
                                    <div className="status-header">
                                        <div className={`status-icon ${status === 'loading' ? 'loading' : status === 'connected' ? 'success' : status === 'error' ? 'error' : 'waiting'}`}>
                                            {status === 'loading' ? '‚è≥' : status === 'connected' ? '‚úì' : status === 'error' ? '‚úï' : '‚óã'}
                                        </div>
                                        <span className="status-title">
                                            {status === 'idle' && 'Waiting...'}
                                            {status === 'loading' && 'Connecting...'}
                                            {status === 'connected' && 'Connected'}
                                            {status === 'error' && 'Error'}
                                        </span>
                                    </div>
                                    <p className="status-message">{statusMsg}</p>
                                    {status === 'loading' && (
                                        <div className="status-progress">
                                            <div className="status-progress-fill" />
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        <div className="section">
                            <div className="section-title">Documents</div>
                            <div 
                                className={`upload-zone ${status !== 'connected' ? 'disabled' : ''}`}
                                onClick={() => status === 'connected' && fileInput.current?.click()}
                                onDragOver={(e) => { e.preventDefault(); if (status === 'connected') e.currentTarget.classList.add('dragover'); }}
                                onDragLeave={(e) => e.currentTarget.classList.remove('dragover')}
                                onDrop={(e) => { e.preventDefault(); e.currentTarget.classList.remove('dragover'); if (status === 'connected') handleUpload(e.dataTransfer.files); }}
                            >
                                <p>Drop files or click to upload</p>
                                <p className="formats">PDF, DOCX, TXT, JSON</p>
                            </div>
                            <input ref={fileInput} type="file" multiple accept=".pdf,.docx,.txt,.md,.json" style={{ display: 'none' }}
                                onChange={(e) => status === 'connected' && e.target.files.length > 0 && handleUpload(e.target.files)} />

                            {documents.length > 0 && (
                                <div className="doc-list">
                                    {documents.map((doc, i) => (
                                        <div key={i} className="doc-item">
                                            <span className="name" title={doc.name}>{doc.name}</span>
                                            <span className="chunks">{doc.chunkCount}</span>
                                            <button className="remove" onClick={() => removeDoc(doc.name)}>‚úï</button>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {chunks.length > 0 && (
                            <div className="section">
                                <div className="section-title">Index Stats</div>
                                <div className="stats">
                                    <div className="stat">
                                        <div className="stat-value">{documents.length}</div>
                                        <div className="stat-label">Docs</div>
                                    </div>
                                    <div className="stat">
                                        <div className="stat-value">{chunks.length}</div>
                                        <div className="stat-label">Chunks</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        <div className="section">
                            <div className="section-title">Settings</div>
                            <div className="slider-group">
                                <div className="slider-header">
                                    <label>Trust Threshold</label>
                                    <span className="slider-value">{trustThreshold.toFixed(2)}</span>
                                </div>
                                <input type="range" min="0" max="1" step="0.05" value={trustThreshold} onChange={(e) => setTrustThreshold(parseFloat(e.target.value))} />
                            </div>
                            <div className="slider-group">
                                <div className="slider-header">
                                    <label>Hybrid Œª</label>
                                    <span className="slider-value">{hybridLambda.toFixed(2)}</span>
                                </div>
                                <input type="range" min="0" max="1" step="0.05" value={hybridLambda} onChange={(e) => setHybridLambda(parseFloat(e.target.value))} />
                            </div>
                            <div className="slider-group">
                                <div className="slider-header">
                                    <label>Top-K</label>
                                    <span className="slider-value">{topK}</span>
                                </div>
                                <input type="range" min="3" max="10" step="1" value={topK} onChange={(e) => setTopK(parseInt(e.target.value))} />
                            </div>
                        </div>
                    </aside>

                    <main className="main-content">
                        <header className="chat-header">
                            <h2>Ask about your documents</h2>
                            <p>Answers verified against sources with trust scoring</p>
                        </header>

                        <div className="chat-messages">
                            {messages.length === 0 ? (
                                <div className="empty-state">
                                    <div className="empty-state-icon">üìÑ</div>
                                    <h3>No messages yet</h3>
                                    <p>{status !== 'connected' ? 'Enter your API key to start' : chunks.length === 0 ? 'Upload documents first' : 'Ask a question!'}</p>
                                </div>
                            ) : messages.map((msg, i) => (
                                <div key={i} className={`message message-${msg.type}`}>
                                    <div className="message-label">{msg.type === 'user' ? 'You' : 'MAISA'}</div>
                                    <div className="message-content">
                                        {msg.content}
                                        {msg.type === 'assistant' && msg.trustScore && (
                                            <>
                                                <div className="trust-indicator">
                                                    <span className={`trust-badge ${getTrust(msg.trustScore.overall).class}`}>
                                                        {getTrust(msg.trustScore.overall).label} {(msg.trustScore.overall * 100).toFixed(0)}%
                                                    </span>
                                                    <span className="trust-details">
                                                        R:{(msg.trustScore.retrieval * 100).toFixed(0)}% E:{(msg.trustScore.entailment * 100).toFixed(0)}% A:{(msg.trustScore.attribution * 100).toFixed(0)}%
                                                    </span>
                                                </div>
                                                {msg.sources?.length > 0 && (
                                                    <div className="sources">
                                                        <div className="sources-title">Sources</div>
                                                        {msg.sources.slice(0, 3).map((src, j) => (
                                                            <div key={j} className="source-item">
                                                                <span className="source-doc">{src.chunk.docName}</span>
                                                                <div className="source-text">{src.chunk.text.slice(0, 200)}...</div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </>
                                        )}
                                    </div>
                                </div>
                            ))}
                            {loading && (
                                <div className="message message-assistant">
                                    <div className="message-label">MAISA</div>
                                    <div className="message-content">
                                        <div className="loading">
                                            <div className="loading-dots"><span></span><span></span><span></span></div>
                                            Searching...
                                        </div>
                                    </div>
                                </div>
                            )}
                            <div ref={chatEnd} />
                        </div>

                        <div className="chat-input-container">
                            <div className="chat-input-wrapper">
                                <textarea
                                    className="chat-input"
                                    value={input}
                                    onChange={(e) => setInput(e.target.value)}
                                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSubmit(); } }}
                                    placeholder={status !== 'connected' ? "Connect API first..." : chunks.length === 0 ? "Upload documents first..." : "Ask a question..."}
                                    disabled={status !== 'connected' || chunks.length === 0 || loading}
                                />
                                <button className="btn btn-primary send-btn" onClick={handleSubmit} disabled={status !== 'connected' || chunks.length === 0 || loading || !input.trim()}>‚Üí</button>
                            </div>
                        </div>
                    </main>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
